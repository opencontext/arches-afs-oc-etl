CREATE SCHEMA IF NOT EXISTS "staging";


create or replace function __arches_tile_view_update() returns trigger as $$
declare
    view_namespace text;
    group_id uuid;
    graph_id uuid;
    parent_id uuid;
    tile_id uuid;
    transaction_id uuid;
    json_data json;
    old_json_data jsonb;
    edit_type text;
begin
    select graphid into graph_id from nodes where nodeid = group_id;
    view_namespace = format('%s.%s', tg_table_schema, tg_table_name);
    select obj_description(view_namespace::regclass, 'pg_class') into group_id;
    if (TG_OP = 'DELETE') then
        select tiledata into old_json_data from tiles where tileid = old.tileid;
        delete from resource_x_resource where tileid = old.tileid;
        delete from public.tiles where tileid = old.tileid;
        insert into bulk_index_queue (resourceinstanceid, createddate)
            values (old.resourceinstanceid, current_timestamp) on conflict do nothing;
        insert into edit_log (
            resourceclassid,
            resourceinstanceid,
            nodegroupid,
            tileinstanceid,
            edittype,
            oldvalue,
            timestamp,
            note,
            transactionid
        ) values (
            graph_id,
            old.resourceinstanceid,
            group_id,
            old.tileid,
            'tile delete',
            old_json_data,
            now(),
            'loaded via SQL backend',
            public.uuid_generate_v1mc()
        );
        return old;
    else
        select __arches_get_json_data_for_view(new, tg_table_schema, tg_table_name) into json_data;
        select __arches_get_parent_id_for_view(new, tg_table_schema, tg_table_name) into parent_id;
        tile_id = new.tileid;
        if (new.transactionid is null) then
            transaction_id = public.uuid_generate_v1mc();
        else
            transaction_id = new.transactionid;
        end if;

        if (TG_OP = 'UPDATE') then
            select tiledata into old_json_data from tiles where tileid = tile_id;
            edit_type = 'tile edit';
            if (transaction_id = old.transactionid) then
                transaction_id = public.uuid_generate_v1mc();
            end if;
            update public.tiles
            set tiledata = json_data,
                nodegroupid = group_id,
                parenttileid = parent_id,
                resourceinstanceid = new.resourceinstanceid
            where tileid = new.tileid;
        elsif (TG_OP = 'INSERT') then
            old_json_data = null;
            edit_type = 'tile create';
            if tile_id is null then
                tile_id = public.uuid_generate_v1mc();
            end if;
            insert into public.tiles(
                tileid,
                tiledata,
                nodegroupid,
                parenttileid,
                resourceinstanceid
            ) values (
                tile_id,
                json_data,
                group_id,
                parent_id,
                new.resourceinstanceid
            );
        end if;
        perform __arches_refresh_tile_resource_relationships(tile_id);
        insert into bulk_index_queue (resourceinstanceid, createddate)
            values (new.resourceinstanceid, current_timestamp) on conflict do nothing;
        insert into edit_log (
            resourceclassid,
            resourceinstanceid,
            nodegroupid,
            tileinstanceid,
            edittype,
            newvalue,
            oldvalue,
            timestamp,
            note,
            transactionid
        ) values (
            graph_id,
            new.resourceinstanceid,
            group_id,
            tile_id,
            edit_type,
            json_data::jsonb,
            old_json_data,
            now(),
            'loaded via SQL backend',
            transaction_id
        );
        return new;
    end if;
    end;
$$ language plpgsql;



    SELECT __arches_create_resource_model_views('9519cb4f-b25b-11e9-8c7b-a4d18cec433a');
    

/* ---------------------------------------------------------------------------------- */ 



                INSERT INTO physical_thing.instances (
                    resourceinstanceid, 
graphid, 
graphpublicationid, 
principaluser_id
                ) SELECT
                    resourceinstanceid::uuid, 
graphid::uuid, 
graphpublicationid::uuid, 
principaluser_id::integer
                
                FROM staging.phys_name_ids
                WHERE (staging.phys_name_ids.resourceinstanceid NOT IN (SELECT resourceinstanceid FROM physical_thing.instances)) AND 
((staging.phys_name_ids.resourceinstanceid::uuid IS NOT NULL))
                ORDER BY staging.phys_name_ids.resourceinstanceid
                
                ;
                


                INSERT INTO physical_thing.name (
                    resourceinstanceid, 
tileid, 
name_content, 
name_type_, 
name_language_, 
nodegroupid
                ) SELECT
                    resourceinstanceid::uuid, 
item_label_tileid::uuid, 
item_label_name_content::jsonb, 
item_label_name_type_::uuid[], 
item_label_name_language_::uuid[], 
item_label_nodegroupid::uuid
                
                FROM staging.phys_name_ids
                WHERE (staging.phys_name_ids.item_label_tileid::uuid NOT IN (SELECT tileid FROM tiles)) AND 
(staging.phys_name_ids.item_label_tileid::uuid IS NOT NULL) AND 
((staging.phys_name_ids.item_label_name_content::jsonb IS NOT NULL))
                ORDER BY staging.phys_name_ids.resourceinstanceid
                
                ;
                


                INSERT INTO physical_thing.identifier (
                    resourceinstanceid, 
tileid, 
identifier_content, 
identifier_type, 
nodegroupid
                ) SELECT
                    resourceinstanceid::uuid, 
id_uri_tileid::uuid, 
id_uri_identifier_content::jsonb, 
id_uri_identifier_type::uuid[], 
id_uri_nodegroupid::uuid
                
                FROM staging.phys_name_ids
                WHERE (staging.phys_name_ids.id_uri_tileid::uuid NOT IN (SELECT tileid FROM tiles)) AND 
(staging.phys_name_ids.id_uri_tileid::uuid IS NOT NULL) AND 
((staging.phys_name_ids.id_uri_identifier_content::jsonb IS NOT NULL))
                ORDER BY staging.phys_name_ids.resourceinstanceid
                
                ;
                


                INSERT INTO physical_thing.identifier (
                    resourceinstanceid, 
tileid, 
identifier_content, 
identifier_type, 
nodegroupid
                ) SELECT
                    resourceinstanceid::uuid, 
id_ark_tileid::uuid, 
id_ark_identifier_content::jsonb, 
id_ark_identifier_type::uuid[], 
id_ark_nodegroupid::uuid
                
                FROM staging.phys_name_ids
                WHERE (staging.phys_name_ids.id_ark_tileid::uuid NOT IN (SELECT tileid FROM tiles)) AND 
(staging.phys_name_ids.id_ark_tileid::uuid IS NOT NULL) AND 
((staging.phys_name_ids.id_ark_identifier_content::jsonb IS NOT NULL))
                ORDER BY staging.phys_name_ids.resourceinstanceid
                
                ;
                


select * from refresh_geojson_geometries();
